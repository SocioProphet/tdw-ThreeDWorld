from typing import List, Union
from json import loads
from pathlib import Path
from tdw.add_ons.add_on import AddOn
from tdw.asset_bundle_creator import AssetBundleCreator


class LISDF(AddOn):
    """
    Parse an [.lisdf file](https://learning-and-intelligent-systems.github.io/kitchen-worlds/tut-lisdf/).

    .lisdf models can't be directly added into TDW; they must first be converted into asset bundles. These asset bundles will be saved to the local disk, meaning that converting .lisdf data to asset bundles is a one-time process.

    Note that this is only a partial implementation of an .lisdf parser. More functionality will be added over time.

    When `read()` is called, asset bundles are automatically generated if they don't already exist. Then this add-on appends commands to the controller to add the objects to the scene.
    """

    def __init__(self):
        super().__init__()
        self.initialized = True

    def read(self, lisdf_path: Union[str, Path], output_directory: Union[str, Path], overwrite: bool = False,
             cleanup: bool = True, send_commands: bool = True, quiet: bool = False, display: str = ":0",
             unity_editor_path: Union[Path, str] = None) -> None:
        """
        Read an .lisdf file and send commands to the build to add the objects to the scene.
        If corresponding asset bundles don't exist in `asset_bundles_directory` or if `overwrite == True`, this function will call the `asset_bundle_creator` Unity project and generate new asset bundles.

        Note that if there are any robots in the scene, you should first create them with [`RobotCreator`](../robot_creator.md), move the asset bundles to `output_directory`, and then set `overwrite=False` (the default value). Otherwise, the robots will be generated as non-motorized composite objects.

        Example source directory:

        ```
        source_directory/
        ....scene/
        ........kitchen.lisdf
        ....models/
        ........counter/
        ............urdf/
        ................counter_0.urdf
        ................textured_objs/
        ....................01.obj
        .................... (etc.)
        ........ (etc.)
        ```

        - In this example, set `lisdf_path` to `"source_directory/scene/kitchen.lisdf"`
        - The location of the .urdf files must match the relative path in `kitchen.lisdf` (in this case, `../models.counter/urdf/counter_0.urdf`)
        - The location of the .obj files must match the relative path in the .urdf files (in this case, `counter_0.urdf` is expecting meshes to be in `textured_objs/`)

        If there are robots in the scene, place the asset bundles in the output directory like this, prior to running `LISDF.read()`:

        ```
        output_directory/
        ....robot/
        ........Darwin/
        ............robot
        ........Linux/
        ............robot
        ........Windows/
        ............robot
        ```

        - `Darwin/robot`, `Linux/robot` and `Windows/robot` are the platform-specific asset bundles.

        Example output directory after running `LISDF.read()`:

        ```
        output_directory/
        ....counter_0/
        ........Darwin/
        ............counter_0
        ........Linux/
        ............counter_0
        ........Windows/
        ............counter_0
        ....robot/
        ........Darwin/
        ............robot
        ........Linux/
        ............robot
        ........Windows/
        ............robot
        ....commands.json
        ```

        - `Darwin/counter_0`, `Linux/counter_0` and `Windows/counter_0` are the platform-specific asset bundles.
        - `commands.json` is the list of commands that can be sent to the build. They will be sent automatically if the `send_commands=True`.

        :param lisdf_path: The path to the .lisdf file as either a string or [`Path`](https://docs.python.org/3/library/pathlib.html).
        :param output_directory: The directory of the object asset bundles as either a string or [`Path`](https://docs.python.org/3/library/pathlib.html). If it doesn't exist, it will be created while the .lisdf models are being converted.
        :param overwrite: If True, overwrite any asset bundles in `asset_bundles_directory`. If False, skip converting models if the asset bundles already exist. This should usually be False, especially if you're using robot asset bundles generated by [`RobotCreator`](../robot_creator.md).
        :param cleanup: If True, delete intermediary files such as .prefab files generated while creating asset bundles.
        :param send_commands: If True, the commands generated from the .lisdf file will be sent the next time `c.communicate()` is called.
        :param quiet: If True, don't print any messages to console.
        :param display: The display to launch Unity Editor on. Ignored if this isn't Linux.
        :param unity_editor_path: The path to the Unity Editor executable, for example `C:/Program Files/Unity/Hub/Editor/2020.3.24f1/Editor/Unity.exe`. If None, this script will try to find Unity Editor automatically.
        """

        if isinstance(lisdf_path, Path):
            src_str = str(lisdf_path.resolve())
        elif isinstance(lisdf_path, str):
            src_str = lisdf_path
        else:
            raise Exception(lisdf_path)
        if isinstance(output_directory, Path):
            dst_str = str(output_directory.resolve())
            dst_path = output_directory
        elif isinstance(output_directory, str):
            dst_str = output_directory
            dst_path = Path(output_directory)
        else:
            raise Exception(output_directory)
        if not dst_path.exists():
            dst_path.mkdir(parents=True)
        # Fix Windows paths.
        dst_str = dst_str.replace("\\", "/")
        src_str = src_str.replace("\\", "/")
        # Generate asset bundles if needed.
        args = [f'-source="{src_str}"',
                f'-output_directory="{dst_str}"']
        if overwrite:
            args.append("-overwrite")
        if cleanup:
            args.append("-cleanup")
        a = AssetBundleCreator(quiet=quiet, display=display, unity_editor_path=unity_editor_path)
        a.call_unity(class_name="LISDFReader",
                     method="Read",
                     args=args)
        # Print the log.
        if not quiet:
            log_path = dst_path.joinpath("log.txt")
            if log_path.exists():
                print(log_path.read_text(encoding="utf-8"))
        # Send the commands, if any.
        commands_path = dst_path.joinpath("commands.json")
        if send_commands and commands_path.exists():
            self.commands.extend(loads(commands_path.read_text(encoding="utf-8")))

    def on_send(self, resp: List[bytes]) -> None:
        pass

    def get_initialization_commands(self) -> List[dict]:
        return []
