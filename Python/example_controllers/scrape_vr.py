import random
from tdw.controller import Controller
from tdw.tdw_utils import TDWUtils
from tdw.add_ons.oculus_touch import OculusTouch
from tdw.add_ons.py_impact import PyImpact
from tdw.physics_audio.object_audio_static import ObjectAudioStatic
from tdw.physics_audio.audio_material import AudioMaterial
from tdw.physics_audio.scrape_material import ScrapeMaterial
from tdw.physics_audio.scrape_model import ScrapeModel
from tdw.physics_audio.scrape_sub_object import ScrapeSubObject
from tdw.physics_audio.collision_audio_event import CollisionAudioEvent
from tdw.librarian import ModelLibrarian
from tdw.vr_data.oculus_touch_button import OculusTouchButton


class OculusTouchPyImpact(Controller):
    """
    Listen to audio generated by PyImpact.
    """

    MODEL_NAMES = ["rh10", "iron_box", "trunck"]

    def __init__(self, port: int = 1071, check_version: bool = True, launch_build: bool = True):
        super().__init__(port=port, check_version=check_version, launch_build=launch_build)
        self.simulation_done = False
        self.trial_done = False
        self.vr = OculusTouch()
        # Quit when the left trigger button is pressed.
        self.vr.listen_to_button(button=OculusTouchButton.primary_button, is_left=True, function=self.quit)
        # End the trial when the right trigger button is pressed.
        self.vr.listen_to_button(button=OculusTouchButton.primary_button, is_left=False, function=self.end_trial)

        # Adjust collision area handling to improve the differentiation between scrapes and impacts.
        CollisionAudioEvent.IMPACT_AREA_NEW_COLLISION = 1e-6
        CollisionAudioEvent.IMPACT_AREA_RATIO = 50

        self.audio_materials = [AudioMaterial.wood_medium, AudioMaterial.ceramic, AudioMaterial.metal]
        self.visual_materials = ["wood_beech_natural", "ceramic_raw_striped", "metal_cast_iron"]
        self.table_surfaces = ["glass_table", "quatre_dining_table", "small_table_green_marble"]
        self.scrape_materials = [ScrapeMaterial.plywood, ScrapeMaterial.ceramic, ScrapeMaterial.sandpaper]

        # Enable PyImpact.
        self.py_impact = PyImpact()
        self.add_ons.extend([self.vr, self.py_impact])
        self.communicate(TDWUtils.create_empty_room(12, 12))

    #def trial(self, cube_audio_material: AudioMaterial, cube_visual_material: str) -> None:
    def trial(self, table_surface, cube_audio_material, cube_visual_material, cube_scrape_material) -> None:
        # Start a new trial.
        self.trial_done = False
        model_name = "prim_cube"
        lib_core = ModelLibrarian("models_core.json")
        lib_flex = ModelLibrarian("models_flex.json")
        lib_special = ModelLibrarian("models_special.json")
        cube_mass = 1.5
        cube_bounciness = 0.4
        cube_record = lib_special.get_record(model_name)
        scrape_surface_model_name = table_surface
        surface_record = lib_core.get_record(scrape_surface_model_name)
        # Add the surface.
        surface_id = self.get_unique_id()

        # Set up scrape model data
        scrape_model = ScrapeModel(model_name=model_name,
                                   visual_material=cube_visual_material,
                                   audio_material=cube_audio_material,
                                   scrape_material=cube_scrape_material,
                                   sub_objects=[ScrapeSubObject(name=cube_record.substructure[0]['name'],
                                                                material_index=0)])
        cube_id = self.get_unique_id()
        commands = self.get_add_physics_object(model_name=scrape_surface_model_name,
                                    library="models_core.json",
                                    object_id=surface_id,
                                    kinematic=True)
        # Add the cube just above the top of the surface.
        commands.extend(self.get_add_physics_object(model_name=model_name,
                                                    library="models_special.json",
                                                    object_id=cube_id,
                                                    position={"x": 0,
                                                              "y": surface_record.bounds["top"]["y"],
                                                              "z": surface_record.bounds["back"]["z"] + 0.1},
                                                    scale_factor={"x": 0.1, "y": 0.1, "z": 0.25},
                                                    default_physics_values=False,
                                                    scale_mass=False,
                                                    mass=cube_mass,
                                                    dynamic_friction=0.5,
                                                    static_friction=0.5,
                                                    bounciness=cube_bounciness))
        commands.extend([self.get_add_material(material_name=cube_visual_material, library="materials_med.json"),
                 {"$type": "set_visual_material",
                  "id": cube_id,
                  "material_name": cube_visual_material,
                  "object_name": cube_record.substructure[0]['name'],
                  "material_index": 0}])
        self.communicate(commands)
        # Define audio for the cube.
        cube_audio = ObjectAudioStatic(name=model_name,
                               object_id=cube_id,
                               mass=cube_mass,
                               bounciness=cube_bounciness,
                               amp=0.8,
                               resonance=0.25,
                               size=2,
                               material=cube_audio_material)

        self.vr.reset()
        self.vr.set_position({"x": 0, "y": 0.0, "z": -1.75})
        # Reset PyImpact.
        self.py_impact.reset(static_audio_data_overrides={cube_id: cube_audio}, scrape_objects={cube_id: scrape_model}, initial_amp=0.9)

        # Wait until the trial is done.
        while not self.trial_done and not self.simulation_done:
            self.communicate([])
        # Destroy the object.
        self.communicate([{"$type": "destroy_object",
                           "id": cube_id},
                          {"$type": "destroy_object",
                           "id": surface_id}])

    def run(self) -> None:
        while not self.simulation_done and not self.simulation_done:
            for table_surface, cube_audio_material, cube_visual_material,cube_scrape_material in zip(["quatre_dining_table", "small_table_green_marble", "glass_table"],
                                                                                                 [AudioMaterial.wood_medium, AudioMaterial.ceramic, AudioMaterial.metal],
                                                                                                 ["wood_beech_natural", "ceramic_raw_striped", "metal_cast_iron"],
                                                                                                 [ScrapeMaterial.plywood, ScrapeMaterial.ceramic, ScrapeMaterial.sandpaper]):
                # Run a trial.
                self.trial(table_surface, cube_audio_material, cube_visual_material, cube_scrape_material)
            # End the simulation.
            self.communicate({"$type": "terminate"})

    def quit(self):
        self.simulation_done = True

    def end_trial(self):
        self.trial_done = True


if __name__ == "__main__":
    c = OculusTouchPyImpact(launch_build=True)
    c.run()
